#=============================================================================
#
#  Copyright (c) Kitware, Inc.
#  All rights reserved.
#  See LICENSE.txt for details.
#
#  This software is distributed WITHOUT ANY WARRANTY; without even
#  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#  PURPOSE.  See the above copyright notice for more information.
#
#=============================================================================
import os
print 'loading', os.path.basename(__file__)

import smtk

from cardformat import CardFormat
from conditionset import ConditionSet

# ---------------------------------------------------------------------
class Writer2D:
  '''Top level writer class for IBAMR input files (2D)
  '''

# ---------------------------------------------------------------------
  def __init__(self, export_spec):
    '''
    '''
    # Member data
    self.component_sequence = None
    self.export_spec_att = None
    self.format_table = None
    self.sim_atts = None

    # Initialize
    self.sim_atts = export_spec.getSimulationAttributes()
    print 'sim_atts', self.sim_atts

    # Get export attribute
    export_atts = export_spec.getExportAttributes()
    if not export_atts:
      raise Exception('ERROR: Missing Export Attribute Manager')

    att_list = export_atts.findAttributes('ExportSpec')
    if not att_list:
      raise Exception('ERROR: Missing ExportSpec attribute')

    self.export_spec_att = att_list[0]

# ---------------------------------------------------------------------
  def write(self, component_sequence, format_table):
    '''
    '''
    ConditionSet.clear()
    self.component_sequence = component_sequence
    self.format_table = format_table

    # Get output filename/path
    filename_item = self.export_spec_att.findFile('OutputFile')
    if not filename_item:
      raise Exception('ERROR: ExportSpec attribute missing OutputFile item')

    output_filename = filename_item.value(0)
    if not output_filename:
      output_filename = 'output.ibamr'
      msg = 'No output file specified; using \"%s\"' % output_filename
      print 'WARNING:', msg
      logger.addWarning(msg)
    print 'output filename', output_filename

    completed = False
    with open(output_filename, 'w') as out:
      out.write('// Generated by CMB\n')
      self.out = out

      for component in self.component_sequence:
        # Get format list
        format_list = self.format_table.get(component.format_list_name)
        if format_list is None:
          print 'WARNING: Missing format list for component', component.name,
          if component.format_list_name != component.name:
            print ' (format list name:', component.format_list_name, ')',
          print
          continue

        # Set component condition (if any)
        if component.set_condition:
          ConditionSet.set_condition(component.set_condition)

        # Components can assign custom method
        if component.custom_component_method is not None:
          if not hasattr(self, component.custom_component_method):
            print 'ERROR: For component', component.name, \
              ', custom_method', component.custom_component_method, \
              'not found'
          else:
            method = getattr(self, component.custom_component_method)
            method(out, component, format_list)
          continue

        # Else use the default component writer
        else:
          self.write_component(out, component, format_list)

        # Unset any component condition
        if component.set_condition:
          ConditionSet.unset_condition(component.set_condition)

      completed = True
      print 'Wrote output file %s' % output_filename
    return completed

# ---------------------------------------------------------------------
  def write_component(self, out, component, format_list):
    '''
    '''
    print 'Writing component', component.name

    # If namelist specifies attribute, process each one
    if component.att_name is not None:
      att = self.sim_atts.findAttribute(component.att_name)
      if att:
        self.write_att(out, att, component, format_list)
    elif component.att_type is not None:
      att_list = self.sim_atts.findAttributes(component.att_type)
      #print 'att_type', component.att_type, 'att_list', att_list
      att_list.sort(key=lambda att: att.name())
      for att in att_list:
        self.write_att(out, att, component, format_list)
      return

    # Otherwise write single component
    else:
      self.begin_component(out, component)
      for card in format_list:
        att_list = self.sim_atts.findAttributes(card.att_type)
        for att in att_list:
          card.write(out, att, tab=component.tab)
      self.end_component(out)

# ---------------------------------------------------------------------
  def write_att(self, out, att, component, format_list):
    '''Writes component for 1 attribute
    '''
    tab = component.tab
    base_path = component.base_item_path
    self.begin_component(out, component)

    for card in format_list:
      #print 'card', card.keyword
      if card.att_type is None:
        card.write(out, att, base_item_path=base_path, tab=tab)
      else:
        card_att_list = self.sim_atts.findAttributes(card.att_type)
        for card_att in card_att_list:
          card.write(out, card_att, base_item_path=base_path, tab=tab)
    self.end_component(out)

# ---------------------------------------------------------------------
  def write_geometry(self, out, component, format_list):
    '''Custom method for writing CartesianGeometry
    '''
    print 'Writing component', component.name
    att_list = self.sim_atts.findAttributes(component.att_type)
    if not att_list:
      print 'ERROR: Missing', component.att_type, 'attribute'
      return

    att = att_list[0]
    tab = component.tab
    self.begin_component(out, component)

    for card in format_list:
      if 'domain_boxes' == card.keyword:
        # Get the grid attribute & base-grid-size item
        att_list = self.sim_atts.findAttributes(card.att_type)
        if not att_list:
          print 'ERROR: Missing attribute type', card.att_type
          continue

        grid_att = att_list[0]
        grid_size_item = grid_att.findInt(card.item_path)
        if not grid_size_item:
          print 'ERROR: Missing item', card.item_path
          continue

        if grid_size_item.numberOfValues() != 2:
          print 'ERROR: Wrong number of values (should be 2) for item', \
            card.item_path
          continue

        upper_x = grid_size_item.value(0) - 1
        upper_y = grid_size_item.value(1) - 1
        value = '[ (0,0), (%d,%d) ]' % (upper_x, upper_y)

        card.write_value(
          out, card.keyword, value, quote_string=False, tab=tab)
      elif card.is_custom:
        print 'TODO', card.keyword
      else:
        card.write(out, att, tab=tab)

    self.end_component(out)

# ---------------------------------------------------------------------
  def write_bc_coefs(self, out, component, format_list):
    '''Custom method for writing velocity BC coefficients
    '''
    if not component.att_name:
      print 'ERROR: Missing att_name for component', component.name
      return

    att = self.sim_atts.findAttribute(component.att_name)
    if not att:
      print 'ERROR: Missing attribute with name', component.att_name
      return

    # Check the enabled group item
    enable_item = att.findGroup('enable')
    if not enable_item.isEnabled():
      return

    print 'Writing component', component.name

    # Initialize CardFormat for temp use
    card = CardFormat('temp')
    tab = component.tab

    self.begin_component(out, component)
    for item_name in ['a', 'b', 'g']:
      item = enable_item.find(item_name)
      coef_item = smtk.attribute.to_concrete(item)
      if item_name != 'a':
        out.write('\n')
      coef_num = coef_item.numberOfValues()
      for i in range(coef_num):
        keyword = '%scoef_function_%d' % (item_name, i)
        value = coef_item.value(i)
        value_string = '\"%s\"' % value
        card.write_value(out, keyword, value_string, tab=tab)

    self.end_component(out)

# ---------------------------------------------------------------------
  def begin_component(self, out, component):
    out.write('\n')
    out.write('%s {' % component.name)
    out.write('\n')

# ---------------------------------------------------------------------
  def end_component(self, out):
    out.write('}\n')
